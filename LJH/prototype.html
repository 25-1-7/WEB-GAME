<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>우주 미화원 게임</title>
  <style>
    canvas { background: black; display: block; margin: 0 auto; }
    #startBtn, #difficultySelect { display: block; margin: 10px auto; padding: 10px 20px; font-size: 18px; }
    #scoreBoard, #timerBoard, #goalBoard {
      text-align: center;
      color: black;
      font-family: monospace;
      background: white;
      padding: 5px;
      border-radius: 5px;
      width: max-content;
      margin: 5px auto;
    }
  </style>
</head>
<body>
  <select id="difficultySelect">
    <option value="1">난이도 1 (하단 제외 반사)</option>
    <option value="2">난이도 2 (상하 제외 반사)</option>
    <option value="3">난이도 3 (사방 게임오버)</option>
  </select>
  <button id="startBtn">게임 시작</button>
  <div id="scoreBoard">점수: 0</div>
  <div id="goalBoard">목표: 100</div>
  <div id="timerBoard">남은 시간: 60s</div>
  <canvas id="gameCanvas" width="800" height="600"></canvas>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const startBtn = document.getElementById("startBtn");
const difficultySelect = document.getElementById("difficultySelect");
const scoreBoard = document.getElementById("scoreBoard");
const timerBoard = document.getElementById("timerBoard");
const goalBoard = document.getElementById("goalBoard");

let ball, paddles, bricks, score, isGameRunning, greenHitCount;
let timer, timeLeft = 60, goal = 100;
let difficulty = 1;
let bonusMode = false;

const brickWidth = 75;
const brickHeight = 20;
const padding = 20;

function initGame() {
  score = 0;
  greenHitCount = 0;
  isGameRunning = true;
  bonusMode = false;
  timeLeft = 60;

  ball = {
    x: canvas.width / 2,
    y: canvas.height / 2,
    dx: 4,
    dy: -4,
    radius: 10,
  };

  paddles = {
    top: { x: (canvas.width - 100) / 2, y: padding, width: 100, height: 10 },
    bottom: { x: (canvas.width - 100) / 2, y: canvas.height - padding - 10, width: 100, height: 10 },
    left: { x: padding, y: (canvas.height - 100) / 2, width: 10, height: 100 },
    right: { x: canvas.width - padding - 10, y: (canvas.height - 100) / 2, width: 10, height: 100 }
  };

  bricks = [];
  for (let i = 0; i < 10; i++) {
    const isBad = Math.random() < 0.2;
    bricks.push({
      x: Math.random() * (canvas.width - brickWidth),
      y: Math.random() * (canvas.height - brickHeight),
      dx: (Math.random() - 0.5) * 2,
      dy: (Math.random() - 0.5) * 2,
      status: 1,
      bad: isBad
    });
  }

  updateScore();
  updateTimer();
  updateGoal();

  if (timer) clearInterval(timer);
  timer = setInterval(() => {
    if (!isGameRunning) return;
    timeLeft--;
    updateTimer();
    if (timeLeft <= 0) {
      clearInterval(timer);
      if (score >= goal) {
        bonusMode = true;
        alert("목표 달성! 보너스 모드 시작!");
      } else {
        isGameRunning = false;
        alert("목표 점수 미달로 게임 종료");
      }
    }
  }, 1000);
}

function updateScore() {
  scoreBoard.innerText = `점수: ${score}`;
}
function updateTimer() {
  timerBoard.innerText = `남은 시간: ${timeLeft}s`;
}
function updateGoal() {
  goalBoard.innerText = `목표: ${goal}`;
}

function drawBall() {
  ctx.beginPath();
  ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
  ctx.fillStyle = "white";
  ctx.fill();
  ctx.closePath();
}
function drawPaddles() {
  for (const key in paddles) {
    const p = paddles[key];
    ctx.beginPath();
    ctx.rect(p.x, p.y, p.width, p.height);
    ctx.fillStyle = "white";
    ctx.fill();
    ctx.closePath();
  }
}
function drawBricks() {
  for (const b of bricks) {
    if (b.status === 1) {
      ctx.beginPath();
      ctx.rect(b.x, b.y, brickWidth, brickHeight);
      ctx.fillStyle = b.bad ? "darkred" : "lime";
      if (b.bad) {
        ctx.lineWidth = 3;
        ctx.strokeStyle = "red";
        ctx.stroke();
      }
      ctx.fill();
      ctx.closePath();
    }
  }
}
function moveBricks() {
  for (const b of bricks) {
    if (b.status === 1) {
      b.x += b.dx;
      b.y += b.dy;
      if (b.x < 0 || b.x + brickWidth > canvas.width) b.dx *= -1;
      if (b.y < 0 || b.y + brickHeight > canvas.height) b.dy *= -1;
    }
  }
}
function scatterDebris(x, y) {
  for (let i = 0; i < greenHitCount; i++) {
    ctx.beginPath();
    ctx.arc(x + Math.random() * 40 - 20, y + Math.random() * 40 - 20, 5, 0, Math.PI * 2);
    ctx.fillStyle = "red";
    ctx.fill();
    ctx.closePath();
  }
}
function spawnBricks(base) {
  const count = Math.floor(Math.random() * 4) + 3;
  for (let i = 0; i < count; i++) {
    bricks.push({
      x: base.x + Math.random() * 60 - 30,
      y: base.y + Math.random() * 60 - 30,
      dx: (Math.random() - 0.5) * 3,
      dy: (Math.random() - 0.5) * 3,
      status: 1,
      bad: false
    });
  }
}
function collisionDetection() {
  for (const b of bricks) {
    if (
      b.status === 1 &&
      ball.x > b.x &&
      ball.x < b.x + brickWidth &&
      ball.y > b.y &&
      ball.y < b.y + brickHeight
    ) {
      b.status = 0;
      ball.dy = -ball.dy;
      if (b.bad) {
        score -= 10;
        greenHitCount++;
        scatterDebris(b.x + brickWidth / 2, b.y + brickHeight / 2);
        spawnBricks(b);
      } else {
        score += 10;
      }
      updateScore();
    }
  }
}

function checkPaddleCollision() {
  const { top, bottom, left, right } = paddles;

  if (ball.y - ball.radius <= top.y + top.height &&
      ball.y - ball.radius >= top.y &&
      ball.x >= top.x && ball.x <= top.x + top.width) {
    ball.dy = Math.abs(ball.dy);
    return true;
  }

  if (ball.y + ball.radius >= bottom.y &&
      ball.y + ball.radius <= bottom.y + bottom.height &&
      ball.x >= bottom.x && ball.x <= bottom.x + bottom.width) {
    ball.dy = -Math.abs(ball.dy);
    return true;
  }

  if (ball.x - ball.radius <= left.x + left.width &&
      ball.x - ball.radius >= left.x &&
      ball.y >= left.y && ball.y <= left.y + left.height) {
    ball.dx = Math.abs(ball.dx);
    return true;
  }

  if (ball.x + ball.radius >= right.x &&
      ball.x + ball.radius <= right.x + right.width &&
      ball.y >= right.y && ball.y <= right.y + right.height) {
    ball.dx = -Math.abs(ball.dx);
    return true;
  }

  return false;
}

function draw() {
  if (!isGameRunning) return;

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawBricks();
  moveBricks();
  drawBall();
  drawPaddles();
  collisionDetection();

  const reflected = checkPaddleCollision();

  if (!reflected && !bonusMode) {
    if (ball.x - ball.radius <= 0) {
      if (difficulty <= 2) ball.dx = Math.abs(ball.dx);
      else return endGame("왼쪽 벽");
    }
    if (ball.x + ball.radius >= canvas.width) {
      if (difficulty <= 2) ball.dx = -Math.abs(ball.dx);
      else return endGame("오른쪽 벽");
    }
    if (ball.y - ball.radius <= 0) {
      if (difficulty <= 1) ball.dy = Math.abs(ball.dy);
      else return endGame("위쪽 벽");
    }
    if (ball.y + ball.radius >= canvas.height) {
      if (difficulty <= 0) ball.dy = -Math.abs(ball.dy);
      else return endGame("아래쪽 벽");
    }
  }

  ball.x += ball.dx;
  ball.y += ball.dy;

  requestAnimationFrame(draw);
}

function endGame(where) {
  isGameRunning = false;
  alert(`${where}에 닿았습니다. 게임 오버`);
}

startBtn.addEventListener("click", () => {
  difficulty = parseInt(difficultySelect.value);
  initGame();
  document.addEventListener("mousemove", e => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    paddles.top.x = Math.min(Math.max(padding, x - paddles.top.width / 2), canvas.width - paddles.top.width - padding);
    paddles.bottom.x = Math.min(Math.max(padding, x - paddles.bottom.width / 2), canvas.width - paddles.bottom.width - padding);
    paddles.left.y = Math.min(Math.max(padding, y - paddles.left.height / 2), canvas.height - paddles.left.height - padding);
    paddles.right.y = Math.min(Math.max(padding, y - paddles.right.height / 2), canvas.height - paddles.right.height - padding);
  });
  draw();
});
</script>
</body>
</html>
